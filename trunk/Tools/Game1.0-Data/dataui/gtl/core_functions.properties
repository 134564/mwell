#=================================#
#[0x0000 ~ 0x2000) : 引擎基本接口    #
#[0x2000 ~ 0x3000) : GUI          #
#[0x3000 ~ 0x4000) : 引擎游戏接口     #
#[0x4000 ~ 0x5000) ：任务                         #
#[0x5000 ~ 0x7000) : 实体项目               #
#[0x7000 ~ 0x7FFF) : 保留                         #
#=================================#

#####################################################################################
#@[0x0000 ~ 0x2000] 引擎基本接口
#@ENGINE SYSCALL FUNCTION ID:
#####################################################################################

#-----------------------------------#
#@System Range: 0x0000 ~ 0x00FF		#
#-----------------------------------#

# 获取版本
0x0000=int GetApiVersion()

# 按键：对应按键keyCode是否被按下，clear为TRUE时清空按键状态
0x0001=boolean KeyPressed(byte keyCode, byte clear)

# 按键：是否无按键被按下
0x0002=boolean NoKeyPressed()

# 按键：模拟按键keyId被按下
0x0003=void SendKeyPressed(int keyId)

#按键：模拟按键keyId按下
0x0004=void SendKeyDown(int keyId)

#按键：模拟按键keyId弹起
0x0005=void SendKeyUp(int keyId)

#按键：清空所有按键标志
0x0006=void ClearKeys()

#按键
0x0007=int MultiKeyCheck(int[] keys, byte clear)

#将临时对象保存到固态堆
0x0008=Object Realize(Object ref)

#创建字符串对象
0x0009=String Object_Create(Object object)

#打开一个脚本
0x000A=int OpenUI(String id)

#取随机数
0x0010=short Random()

#获取当前时间
0x0011=int GetTime()

#获取系统时间
0x0012=int GetSystemTime()

#获取
0x0013=int GetSystemTick()

#获取
0x0014=int GetServerTime()

#判断对象是否为空：空返回TRUE；否则返回FALSE
0x0015=boolean IsNull(Object obj)

#判断一个对象是否不为空：不空返回TRUE；否则返回FALSE
0x0016=boolean IsNotNull(Object obj)

#取非
0x0017=int Not(int value)

#字符串转int
0x0018=int StrToInt(String str)

#int转字符串
0x0019=String IntToStr(int i)

#int转成long
0x0020=Long IntToLong(int lInt, int hInt)

#long转成int
0x0021=int[] LongToInt(Long long)

#int转成object
0x0022=Object IntToObj(int value)

#object转成int
0x0023=int ObjToInt(Object o)

#取对象长度
0x0024=int Length(Object o)

#int转换成16进制表示的字符串
0x0025=String IntToStrHex(int i)

#object转换成int数组
0x0026=int[] ObjToIntArray(Object obj)

#打印int
0x0027=void PrintInt(int value)

#打印字符串
0x0028=void PrintObject(Object obj)

#
0x0029=String[] GetJavaStringArray(int count)

#
0x0030=int[] GetIntArray(int count)

#
0x0031=ImageSet[] GetJavaImageArray(int count)

#copy数组
0x0032=void ArrayCopy(int[] src, int start, int[] des, int start, int lenght)

#java专有：
0x0033=String GetSystemProperty(String propertyName)

#java专有
0x0034=String GetAppProperty(String propertyName)

#释放全局变量
0x0035=void DeleteGlobalVar(String key)

#设置全局int变量
0x0036=void SetGlobalInt(String key, int value)

#获取全局int变量
0x0037=int GetGlobalInt(String key)

#设置全局string变量
0x0038=void SetGlobalString(String key, String value)

#获取全局String变量
0x0039=String GetGlobalString(String key)

#设置全局object变量
0x0040=void SetGlobalObject(String key, Object value)

#获取全局object变量
0x0041=Object GetGlobalObject(String key)

#退出游戏
0x0042=void ExitGame()

#打开wap浏览器
0x0043=void OpenWAPPage(String url)

#发送短信（Symbian专有）
0x0044=void SendSMS(String number, String content)

#创建网络连接
0x0045=void CreateConnection(String url)

#关闭网络连接
0x0046=void CloseConnection()

#使用http同步下载
0x0047=Object DownloadPage(String url, boolean useProxy, Hashtable requestProperties, byte[] postData)

#关闭下载
0x0048=void CancelDownload(Object ref)

#获取下载数据
0x0049=byte[] GetDownloadData(Object ref)

#使用http异步下载
0x0050=Object DownloadPageAsync(String url, boolean useProxy, Hashtable requestProperties, byte[] postData)

#获取下载状态
0x0051=int GetDownloadState(Object thread)

#获得一个计时器
0x0052=int GetVMCounter(int counterTime)

#重置一个计时器的开始时间为当前时间
0x0053=void VMCounterReset(int counterkey)

#获得计时器的剩余秒数
0x0054=int GetSaveTimeSec(int vmCounterKey)

#获得计时器的剩余毫秒数
0x0055=int GetSaveTimeMillis(int vmCounterKey)

#删除一个计时器
0x0056=void RemoveVMCounter(int vmCounterKey)

#删除所有计时器
0x0057=void RemoveAllVMCounter()

#解压zip文件
0x0058=byte[] GZIP_Inflate(byte[] data)

#求平方根
0x0059=int getSqrt(int value)

#求绝对值
0x0060=int MathAbs(int value)

#
0x0061=Object GetWorldProc()

#读取游戏数据
0x0062=Object ReadGameData(Object processor, String dataName)

#保存游戏数据
0x0063=void SaveGameData(Object processor, String dataName, Object data)

#删除游戏数据
0x0064=void RemoveGameData(Object processor, String dataName)

#
0x0065=Object ReadWorldData(String dataName)

#
0x0066=void SaveWorldData(String dataName, Object data)

#
0x0067=void RemoveWorldData(String dataName)

#
0x0068=void SetProcVMData(Object processor, Object vmData)

#
0x0069=Object GetProcVMData(Object processor)

#
0x0070=void GC()

#0x00DE=int ResGetWorldAreaId()
0x0071=int GetWorldAreaId()

#0x00DF=int ResGetGotoMapId()
0x0072=int GetGotoMapId()

#0x00E0=int ResGetGotoMapInstanceId()
0x0073=int GetGotoMapInstanceId()

#0x010E=String GetPlayerName()
0x0074=String GetPlayerName()

#todo 0x50CD
#0x0075=Object GetRoleHkAnimatePlayer()
#todo 0x50A8
#0x0076=Object GetProcessor(int type, int id)
#todo 0x50A6
#0x0077=Object GetRoleProcessor()
#0x00F4=void ResCleanAnimateCache()
# 清除缓存里所有所有的对象....慎用
0x0078=void CleanAnimateCache()

0x0079=void Show_SysAlert(String title, String alertText, int timeout)

#其它System接口在这里添加[0x007A~0x00FF]

# 立刻释放缓存中的一个资源。
0x007A=void AnimateCache_Release(String name)

#-----------------------------------#
#@Graphic Range: 0x0100 ~ 0x01FF	#
#-----------------------------------#

#获取屏幕宽度
0x0100=int GetScreenWidth()

#获取屏幕高度
0x0101=int GetScreenHeight()

#获取系统Graphic
0x0102=Object GetSystemGraphics()

#设置Graphic颜色
0x0103=void SetColor(Object g, int color)

#设置pen的风格是否为圆点
0x0104=void SetStrokeStyle(Graphics g,boolean dotted)

#设置clip区域
0x0105=void SetClip(Object g, int x, int y, int width, int height)

#获取clip区域
0x0106=int[] GetClip(Object g)

#创建ImageSet对象
0x0107=Object CreateImage(int width, int height)

#获取ImageSet对象的Graphic
0x0108=Object GetImageGraphics(Object img)

#获取字体高度
0x0109=int GetFontHeight()

#获取行高
0x0110=int GetLineHeight()

#获取字符串在屏幕上的宽度
0x0111=int StringWidth(String s)

#绘制图片
0x0112=void DrawImage(Object g, Object img, int x, int y, int anchor)

#绘制字符串
0x0113=void DrawString(Object g, String str, int x, int y, int anchor)

#绘制3d字符串
0x0114=void Draw3DString(Object g, String s, int x, int y, int frontColor, int bgColor, int achor)

#填充带alpha值的矩形
0x0115=void FillAlphaRect(Object g, int argb, int x, int y, int width, int height)

#绘制直线
0x0116=void DrawLine(Object g, int x1, int y1, int x2, int y2)

#填充圆角矩形
0x0117=void FillRoundRect(Object g, int x, int y, int width, int height, int hr, int vr)

#绘制圆角矩形
0x0118=void DrawRoundRect(Object g, int x, int y, int width, int height, int hr, int vr)

#填充三角形
0x0119=void FillTriangle(Object g, int x1, int y1, int x2, int y2, int x3, int y3)

#绘制矩形
0x0120=void DrawRect(Object g, int x, int y, int width, int height)

#填充矩形
0x0121=void FillRect(Object g, int x, int y, int width, int height)

#绘制圆
0x0122=void DrawCycle(Object g,int x,int y,int r)

#填充圆
0x0123=void FillCycle(Object g,int x,int y,int r)

#绘制椭圆
0x0124=void DrawEllipse(Object g,int x,int y,int r1,int r2)

#填充椭圆
0x0125=void FillEllipse(Object g,int x,int y,int r1,int r2)

#其它Graphic接口在这里添加[0x011A~0x01FF]

#-----------------------------------#
#@String Range: 0x0200 ~ 0x02FF		#
#-----------------------------------#

#将字符串转换成UTF格式字符串
0x0200=byte[] String_ToUTF(String str)

#在字符串尾部添加字符串
0x0201=String String_Append(String obj, String str)

#求字符串字符个数
0x0202=int String_Length(String obj)

#取子字符串
0x0203=String String_SubString(String obj, int pos, int length)

#查找字符串
0x0204=int String_Find(String obj, String str, int from)

#向一个字符串末尾添加一个整数
0x0205=String String_AppendInt(String obj, int intvalue)

#字符串比较
0x0206=boolean String_Equal(String obj, String str)

#获取字符串中某一索引的字符
0x0207=int String_CharAt(String obj, int index)

#去掉字符串前后的空格
0x0208=String String_Trim(String obj)

#创建一个字符串对象
0x0209=String String_Create2(byte[] data, String encoding)

#替换字符串
0x0210=String String_ReplaceChar(String str, String src, String dest)

#向一个字符串末尾添加一个字符
0x0211=String String_AppendChar(String str, int ch)

#向一个字符串中插入一个字符串
0x0212=String String_InsertString(String str, int pos, String insertString)

#判断字符串是否以另外一个字符串开头
0x0213=boolean String_StartsWith(String str, String prefix)

#将vector中字符串合并
0x0214=String String_Merge(Vector v)

#判断字符串是否以另外一个字符串结尾
0x0215=boolean String_EndsWith(String str, String endfix)

#创建字符串buffer
0x0216=Object StringBuffer_Create()

#向一个字符串末尾添加一个字符串
0x0217=void StringBuffer_Append(Object strBuffer, String str)

#设置字符串buffer的长度
0x0218=void StringBuffer_SetLength(Object strBuffer, int newLength)

#将字符串buffer转换成String对象
0x0219=String StringBuffer_ToString(Object strBuffer)

#其它String接口在这里添加[0x0214~0x02FF]

#---------------------------------------#
#@AnimatePlayer Range: 0x0300 ~ 0x03FF	#
#---------------------------------------#

#
0x0300=void AnimatePlayer_SetMirror(Object animatePlayer, boolean isMirror)

#
0x0301=boolean AnimatePlayer_GetMirror(Object animatePlayer)

#
0x0302=Object AnimatePlayer_GetCopy(Object AnimatePlayer)

#设置动画显示状态0x00D1=void SetAnimateShow
0x0303=void AnimatePlayer_SetShow(AnimatePlayer animatePlayer, boolean shown)

#获取动画显示状态0x00D2=boolean GetAnimateShow
0x0304=boolean AnimatePlayer_GetShow(AnimatePlayer animatePlayer)

#获取动画索引 0x00D3=int GetAnimateIndex
0x0305=int AnimatePlayer_GetIndex(AnimatePlayer animatePlayer)

#0x00D6=void ResCreateAnimatePlayer
0x0306=Object AnimatePlayer_Create(String animateName, Object animateSet)

#
0x0307=void AnimatePlayer_Cycle(Object obj)

#0x00E5=void ResSetAnimatePlayerAnchor
0x0308=void AnimatePlayer_SetAnchor(Object animatePlayer, int anchor)

#0x00E6=void ResGetAnimatePlayerBox
0x0309=void AnimatePlayer_GetAnimateBox(Object animatePlayer, int index)

#0x00EC=void ResAnimatePlayerDraw
0x030A=void AnimatePlayer_Draw(Object animatePlayer, Object g, int x, int y)
0x030B=int AnimatePlayer_PlayStandalone(Object _animatePlayer, int x, int y, int tick, int check)

#其它AnimatePlayer接口在这里添加[0x030B~0x03FF]

#在屏幕上播放一个独立的动画。在Java Engine中用GameSeparateAnimate实现。
#返回动画的key。
0x030B=int AnimatePlayer_PlayStandalone(Object _animatePlayer, int x, int y, int playType,int tick, int check)

0x030C=int AnimatePlayer_PlayStandalone2(Object _animatePlayer, int x, int y,int index, int playType,int callBackIndex, Object callBackParams,Object data)

#-----------------------------------#
#@AnimateSet Range: 0x0400 ~ 0x04FF	#
#-----------------------------------#

#0x00F5 createAnimateSet
# 2010/12/11 Light: 改成从ctn中分析pip列表，只能用于load本地资源
0x0400=Object AnimateSet_Create3(String ctn, boolean cache)

#0x002E或者0x00D5ResCreateAnimateSet作用一样
0x0401=Object AnimateSet_Create2(ImageSet[] imgs, byte[] ctnData)

#
0x0402=Object AnimateSet_Create(ImageSet[] imgs, String ctnFile)

#
0x0403=void AnimateSet_DrawFrame(Object set, Object g, int frame, int x, int y)

#
0x0404=void AnimateSet_DrawAnimate(Object set, Object g, int index, int tick, int x, int y)

#
0x0405=int AnimateSet_GetAnimateLength(Object set, int index)

#
0x0406=Object AnimateSet_GetAnimateBox(Object set, int index)

#其它AnimateSet接口在这里添加[0x0407~0x04FF]

#-----------------------------------#
#@ImageSet Range: 0x0500 ~ 0x05FF	#
#-----------------------------------#
# 2010/12/11 Light: 统一动画图片资源创建接口，所有用文件名载入的图片必须通过AnimateCache
# ImageSet_Create1和ImageSet_Create2删除，ImageSet_Create增加cache参数。
0x0500=ImageSet ImageSet_Create(String fileName, boolean cache)
#0x0501=ImageSet ImageSet_Create1(String fileName, int rows, int cols)
#0x0502=ImageSet ImageSet_Create2(String fileName)
0x0503=ImageSet ImageSet_Create4(byte[] imgData)
0x0504=void ImageSet_DrawFrame(ImageSet obj, Object g, int frame, int x, int y, int anchor)
0x0505=int ImageSet_GetFrameWidth(ImageSet obj, int frame)
0x0506=int ImageSet_GetFrameHeight(ImageSet obj, int frame)
0x0507=void ImageSet_Gray(ImageSet obj)
0x0508=void ImageSet_Lighter(ImageSet obj, int v)
0x0509=void ImageSet_Darker(ImageSet obj, int v)
0x0510=void ImageSet_Mask(ImageSet obj, int v)
0x0511=void ImageSet_DrawFrame2(ImageSet obj, Object g, int frame, int x, int y, int trans, int anchor)

#其它ImageSet接口在这里添加[0x050C~0x05FF]

#-----------------------------------#
#@Stream Range: 0x0600 ~ 0x06FF		#
#-----------------------------------#
0x0600=int Stream_ReadUByte(Stream s)
0x0601=int Stream_ReadUShort(Stream s)
0x0602=Stream Stream_Create(byte[] buf)
0x0603=Stream Stream_Create2()
0x0604=int Stream_ReadInt(Stream s)
0x0605=short Stream_ReadShort(Stream s)
0x0606=byte Stream_ReadByte(Stream s)
0x0607=boolean Stream_ReadBoolean(Stream s)
0x0608=String Stream_ReadUTF(Stream s)
0x0609=void Stream_WriteInt(Stream s, int i)
0x0610=void Stream_WriteShort(Stream s, short s)
0x0611=void Stream_WriteUTF(Stream s, String s)
0x0612=void Stream_WriteByte(Stream s, byte b)
0x0613=void Stream_WriteBoolean(Stream s, boolean b)
0x0614=int Stream_Length(Stream s)
0x0615=byte[] Stream_ToBytes(Stream s)
0x0616=void Stream_ReadBytes(Stream s, byte[] bs)
0x0617=void Stream_WriteBytes(Stream s, byte[] bs)

#其它Stream接口在这里添加[0x0612~0x06FF]

#-----------------------------------#
#@Form Range: 0x0700 ~ 0x07FF		#
#-----------------------------------#
#
0x0700=Object Form_Create(String title)
#
0x0701=void Form_AppendTextField(Object form, String name, String value, int maxLength, int type)
#
0x0702=void Form_AddCommand(Object form, String text, int type, int priority)
#
0x0703=void Form_Show(Object form)
#
0x0704=String Form_GetFieldText(Object form, int index)
#0x0053=void TextField_SetText
0x0705=void Form_SetTextField(Object form, int index, String text)
#
0x0706=String Form_GetLastSelection()
#
0x0707=void Form_AppendChoiceGroup(Object form, String label, int choiceType, String[] choices)
#
0x0708=void Form_SetChoiceSelection(Object form, int fieldIndex, boolean[] flags)
#
0x0709=boolean[] Form_GetChoiceSelection(Object form, int fieldIndex)
#
0x0710=void Form_InsertStringItem(Object form, int fieldIndex, String lable, String text)
#0x005A=int TextField_GetCaretPosition
0x0711=int Form_GetTextFieldCaretPosition(Object form, int index)

#其它Form接口在这里添加[0x070C~0x07FF]

#================================================================================================
#@[0x0800 ~ 0x08FF]
#@引擎基本接口---UWAP SYSCALL FUNCTION ID:
#================================================================================================
#
0x0800=UWAPSegment UWAP_Create(int type, boolean needSerial)

#
0x0801=int UWAP_GetType(UWAPSegment us)

#
0x0802=void UWAP_Reset(UWAPSegment us)

#
0x0803=int UWAP_ReadInt(UWAPSegment us)

#
0x0804=short UWAP_ReadShort(UWAPSegment us)

#
0x0805=byte UWAP_ReadByte(UWAPSegment us)

#
0x0806=boolean UWAP_ReadBoolean(UWAPSegment us)

#
0x0807=String UWAP_ReadString(UWAPSegment us)

#
0x0808=void UWAP_WriteInt(UWAPSegment us, int i)

#
0x0809=void UWAP_WriteShort(UWAPSegment us, short s)

#预留0x080A---0x080F

#
0x0810=void UWAP_WriteString(UWAPSegment us, String s)

#
0x0811=void UWAP_WriteByte(UWAPSegment us, byte b)

#
0x0812=void UWAP_WriteBoolean(UWAPSegment us, boolean b)

#
0x0813=int[] UWAP_ReadInts(UWAPSegment us)

#
0x0814=short[] UWAP_ReadShorts(UWAPSegment us)

#
0x0815=byte[] UWAP_ReadBytes(UWAPSegment us)

#
0x0816=boolean[] UWAP_ReadBooleans(UWAPSegment us)

#
0x0817=String[] UWAP_ReadStrings(UWAPSegment us)

#
0x0818=void UWAP_WriteInts(UWAPSegment us, int[] ia)

#
0x0819=void UWAP_WriteShorts(UWAPSegment us, short[] sa)

#预留0x081A---0x081F

#写多个String到UWAPSegment
0x0820=void UWAP_WriteStrings(UWAPSegment us, String[] sa)

#
0x0821=void UWAP_WriteBooleans(UWAPSegment us, boolean[] ba)

#
0x0822=void UWAP_WriteBytes(UWAPSegment us, byte[] ba)

#
0x0823=int SendRequest(UWAPSegment seg)

#
0x0824=UWAPSegment GetNextPacket()

#
0x0825=void UWAP_SetHandled(UWAPSegment us, boolean flag)

#
0x0826=void BroadcastPacket(UWAPSegment seg)

#
0x0827=int UWAP_GetSerial(UWAPSegment seg)

#
0x0828=void UWAP_SetNeedResponse(UWAPSegment seg, boolean value)

#
0x0829=int UWAP_ReadUByte(UWAPSegment seg)

#预留0x082A---0x082F

#
0x0830=int UWAP_ReadUShort(UWAP_Segment seg)

#================================================================================================
#@[0x0900 ~ 0x09FF]
#@引擎基本接口---Vector SYSCALL FUNCTION ID:
#================================================================================================
#
0x0900=Vector Vector_Create()

#
0x0901=int Vector_Size(Vector v)

#
0x0902=void Vector_Add(Vector v, Object obj)

#
0x0903=void Vector_Remove(Vector v, int index)

#
0x0904=Object Vector_Get(Vector v, int index)

#
0x0905=void Vector_Clear(Vector v)

#
0x0906=void Vector_InsertAt(Vector v,Object obj,int index)

#
0x0907=Object[] Vector_To_Array(Vector v)

#================================================================================================
#@[0x0A00 ~ 0x0AFF]
#@引擎基本接口---HashTable SYSCALL FUNCTION ID:
#================================================================================================
#创建系统的hashtable
0x0A00=Object Hashtable_Create()

#创建SortHashtable
0x0A01=Object SortHashtable_Create()

#
0x0A02=Object Hashtable_GetKey(Object table, int index)

#
0x0A03=Object Hashtable_GetValue(Object table, int index)

#
0x0A04=void Hashtable_Clear(Hashtable table)

#
0x0A05=void Hashtable_Put(Hashtable table, Object key, Object value)

#
0x0A06=Object Hashtable_Get(Hashtable table, Object key)

#
0x0A07=void Hashtable_Remove(Hashtable table, Object key)

#
0x0A08=Object[] Hashtable_GetKeys(Hashtable table)

#
0x0A09=Object[] Hashtable_GetValues(Hashtable table)

#预留0x0A0A---0x0A0F

#
0x0A10=int Hashtable_Size(Hashtable table)

#
0x0A11=boolean Hashtable_Contains(Hashtable table, Object value)

#
0x0A12=boolean Hashtable_ContainsKey(Hashtable table, Object key)

#
0x0A13=void Set_Touch_Flag(boolean flag)

#其他VM接口

#0x0113=void ResetClient(int type)
0x0B00=void ResetClient(int type)

# 设置客户端loading状态，在loading状态才会执行RMS保存操作。
0x0B01=void SetLoading(boolean value)

######################################################################################
#@[0x2000 ~ 0x3000]
#@GUI SYSCALL FUNCTION ID:
######################################################################################
#-----------------------------------#
#GWidget Range: 0x2000 ~ 0x2010		#
#-----------------------------------#
#请求将当前控件置顶.
0x2000=void Gui_GW_RequestToTop(GWidget this)

#请求将当前控件置底.
0x2001=void Gui_GW_RequestToBottom(GWidget this)

#设置当前控件的有效范围.
0x2002=void Gui_GW_SetBound(GWidget this, int x, int y, int width, int height)

#请求获取焦点.
0x2003=void Gui_GW_RequestFocus(GWidget this)

#使得当前控件无效,从而自动进行布局.
0x2004=void Gui_GW_Invalidate(GWidget this)

#使得当前控件无效,从而自动进行布局.
0x2005=void Gui_GW_Validate(GWidget this)

#获取该widget的父控件.
0x2006=Object Gui_GW_GetParentWidget(GWidget this)

#调用java/C++类代码绘制该widget
0x2007=void Gui_GW_PaintWidget(GWidget this)

#获得改空间所属的GVMCanvasUnit
0x2008=Object Gui_GW_GetVMCU(GWidget this)

#获取该widget的绝对坐标.
0x2009=int[] Gui_GW_getAbsPos(GWidget this)

#获取该widget的clip区域
0x200A=int[] Gui_GW_GetWidgetClipArea(GWidget this)

#判断当前控件是否获取焦点.
0x200B=boolean Gui_GW_IsFocused(GWidget this)

#创建一个GWidget.
0x200C=int Gui_GW_makeGWidget(GWidget this, String widgetName)

#销毁一个GWidget.
0x200D=void Gui_GW_destroyGWidget(GWidget this)

#设置一个widget是否为显示
0x200E=void Gui_GW_SetVisible(GWidget gWidget,boolean isVisible)
0x200F=void Gui_SetEnabelCover(boolean isEnabel)

#设置控件是否允许覆盖父控件的border和inset.
#本方法只需要在初始化时调用一次既可
0x200F=void Gui_SetEnabelCover(boolean isEnabel);

#
#GContainer Range: 0x2011 ~ 0x2020
#
#创建一个GContainer
0x2011=Object Gui_GC_MakeGContainer(GContainer this, String widgetName)

#添加一个子控件.
0x2012=void Gui_GC_AddChildWidget(GContainer this, GWidget child, int constraint)

#删除一个子控件.
# 注意，这个控件不会被实际释放，如果要释放它，请调用Gui_GW_destroyGWidget
0x2013=void Gui_GC_RemoveChildWidget(GContainer this, GWidget child)

#为容器添加line layout.
0x2014=void Gui_GC_SetLineLayout(GContainer this, int orientation, int alignement, int gap)

#为容器添加border layout.
0x2015=void Gui_GC_SetBorderLayout(GContainer this, int leftGap, int upGap, int rightGap, int bottomGap)

#为容器添加grid layout.
0x2016=void Gui_GC_SetGridLayout(GContainer this, int cols, int rows)

#为容器内的grid layout子控件添加限制条件.
0x2017=void Gui_GC_SetGridLayoutConstraint(GContainer this, GWidget widget, int gridX, int gridY, int gridWidth, int gridHeight, int insetLeft, int insetTop, int insetRight, int insetBottom)

#执行一次pack操作.
0x2018=void Gui_GC_Pack(GContainer this)

#设置子控件的偏移量
#同时把所有子控件的abs坐标重置，在paint时会重新计算位置
0x2019=void Gui_GC_SetChildrenOffset(GContainer this, int xOffset, int yOffset)

#清空GContainer中的子控件.如果要同时销毁子控件，则设置destroy为TRUE
0x201A=void Gui_GC_Clear(GContainer this, boolean destroy)
#0x201A=void Gui_GC_Clear(GContainer this)

#获取container被layout过后, 按照一定顺序返回的被布局控件序列.
0x201B=Object[] Gui_GC_GetLayoutedWidgets(GContainer this)

#获取container的子控件
0x201C=int[] Gui_GC_GetChildrenWidgets(GContainer this)

#执行一次layout操作
0x201D=void Gui_GC_doLayout(GContainer this)

#设置layout的间隙
0x201E=void Gui_GC_SetLayoutGaps(GContainer this, int hGap, int vGap)

#插入一个控件到容器控件当中的index位置.
0x201F=void Gui_GC_InsertChildWidget(GContainer this, GWidget child, int index)

#释放layoutedWidgets
#NOTE: 此方法java版本不用实现，c版本专有
0x2020=void Gui_GC_DestroyLayoutedWidgets(Object layoutDataInfo)

#释放childrenWidgets
#NOTE: 此方法java版本不用实现，c版本专有
0x2021=void Gui_GC_FreeChildrenWidgets(int[] childrenWidgets)

#判断控件是否是GContainer中的子控件或者是子控件的子控件……
0x2022=boolean Gui_GC_IsInContainer(GContainer this, GWidget widget)

#根据index获取子控件
0x2023=int Gui_GC_GetChildByIndex(GContainer this, int index)
#
#GLabel Range: 0x2031 ~ 0x2040
#
#创建一个GLabel.
0x2031=Object Gui_GL_MakeGLabel(GLabel this, String widgetName, String text)

#设置GLabel中的图片和文本资源.
0x2032=void Gui_GL_SetLabelText(GLabel this, String text)

0x2033=String Gui_GL_GetLabelText(GLabel this)

#
#GButton Range: 0x2041 ~ 0x2050
#
#创建一个GButton
0x2041=Object Gui_GBtn_MakeGButton(GButton this, String widgetName, String text)

#
#GCheckBox Range: 0x2051 ~ 0x2060
#
0x2051 = Object Gui_GCBOX_MakeGCheckBox(GCheckBox this, String widgetName, String text)

0x2052 = void Gui_GCBOX_DealEvent(GCheckBox this)

#
#GGameIcon Range: 0x2061 ~ 0x2070
#
#创建一个GGameIcon
0x2061=Object Gui_GGI_MakeGGameIcon(GGameIcon this, String widgetName, Object[] animateSetList)
#为GGameIcon设置动画资源animateplayer数组.
0x2062=void   Gui_GGI_SetAnimatePlayerList(GGameIcon this, Object[] apList)

#
#GIcon Range: 0x2081 ~ 0x2090
#
0x2081 = Object Gui_GI_MakeGIcon(GIcon this, String widgetName)

#
#GImageNumber Range: 0x2091 ~ 0x20A0
#
#创建一个GImageNumber
0x2091=Object Gui_GIN_MakeGImageNumber(GImageNumber this, String widgetName, ImageSet numberSrc)

#设置ImageNumber的初始显示值
0x2092=void Gui_GIN_SetImageNumber(GImageNumber this, String number)

#
#Reserved Range: 0x20A1 ~ 0x20B0
#
#创建一个TextArea
0x20A1=Object Gui_GTA_MakeGTextArea(GTextArea this, String widgetName)

#设置TextArea的文本内容
0x20A2=void Gui_GTA_setText(GTextArea this, String text)

#重置TextArea的文本内容
0x20A3=void Gui_GTA_reset(GTextArea this)

#获取TextArea的文本内容
0x20A4=String Gui_GTA_getText(GTextArea this)

#
#Reserved Range: 0x20B1 ~ 0x20C0
#创建一个TextField
0x20B1=Object Gui_GTF_MakeGTextField(GTxtField this, String widgetName, boolean isMultiline)
0x20B2=String Gui_GTF_GetText(GTxtField this)
0x20B3=void Gui_GTF_SetText(GTxtField this, String text)
0x20B4=void Gui_GTF_RequestFocus(GTxtField this)
0x20B5=void Gui_GTF_Show(GTxtField this, boolean show)
0x20B6=void Gui_GTF_setBound(GTxtField this, int x, int y, int width, int height)
0x20B7=void Gui_GTF_ReleaseFocus(GTxtField this)

#
#GProgressBar Range: 0x2111 ~ 0x2120
#
0x2111 = Object Gui_GPB_MakeGProgressBar(GProgressBar this, String widgetName, ImageSet ProgressFrame, ImageSet ProgressContent, int nImageFrameIndex, int progressIndex, int max, int min, int EGLayoutOrientation, int tipPaint)

#
#GRadioButton Range: 0x2121 ~ 0x2130
#
0x2121 = Object Gui_GRB_MakeGRadioButton(GRadioButton this, String widgetName, String caption)

#
#GVMCanvasUnit Range: 0x2131 ~ 0x2140
#
0x2131=Object Gui_GVMCU_MakeGVMCU(GVMCanvasUnit this, String widgetName)

#获取GVMCanvasUnit中当前焦点控件
0x2132=Object Gui_GVMCU_GetFocusedWidget(GVMCanvasUnit this)

#从GTL中移除GVMCanvasUnit
0x2133 = void Gui_GVMCU_RemoveWidget(GVMCanvasUnit this)

#收集CallStack方法 added by zxf 12-6-2010
0x2134 = void Gui_GVMCU_invalidateCallStack(GVMCanvasUnit this)


#加载UI VM中控件的的某一类型的VM函数.
#@param type 要加载的vm函数类型(Cycle, Paint, or Destroy).
0x2182=int[] Gui_GUI_LoadVMCallee(int type)

#0x2183 ~ 0x2185 
# TO ADD HERE

#加载ui脚本内的控件事件.
0x2186=int[] Gui_GUI_LoadVMEvent()
#获取当前触摸点的位置, 用于计算dragged事件的offset.
0x2187=int[] Gui_GUI_getCurrentTouchPos()
#获取上次触摸点的位置, 用于计算dragged事件的offset.
0x2188=int[] Gui_GUI_getPrevTouchPos()

#显示字符串
0x21A3 = void Gui_DrawText(Object gc, int x, int y, int hAline, int vAline, String caption)
#计算输入整形数据的位数
0x21A8 = int Gui_countbit(int number)

0x21A9 = Object Gui_getTouchedWidget(GVMCanvasUnit this, int x, int y)


#================================================================================================
#VM Sprite引擎游戏接口
#Range: 0x3000 ~ 0x31FF
#================================================================================================
#
0x3000=void Sprite_AddToWorld(Object sprite)

#
0x3001=void Sprite_RequestDestroy(Object sprite)

# 强制立刻销毁精灵。
0x3002=void Sprite_Destory(Object sprite)

# 2010/12/12 Light: 取消，不在引擎实现。
#0x3002=void Sprite_SetFly(Object sprite, boolean fly)

# 2010/12/12 Light: 取消，不在引擎实现。
#0x3003=boolean Sprite_IsFly(Object sprite)

#设置动画
0x3004=void Sprite_SetAnimateIndex(Object processor, String _animateName, int _index, int _playType, int _callBackIndex)

#
0x3005=void Sprite_SetAnimateIndex2(Object processor, String _animateName, int _index, int _playType, int _callBackIndex, Object callbackData)

#添加飞行文字
0x3006=void Sprite_AddFlyString(Object processor, int _type, String _str, int _number, int _paletteColor, int _distance, int _time, int _order, int _delayTick)

#添加需要回调的飞行文字
0x3007=void Sprite_AddFlyString2(Object _processor, int _type, String _str, int _number, int imageidx,int _paletteColor, int _distance, int _time, int _order, int _delayTick, int funcId, Object callbackData)

#添加侧漂文字
0x3008=void Sprite_AddAcrossFlyString(Object processor, int _type, String _str, int _number, int _paletteColor, int _dir, int _hCycleCount, int _hSpeed, int _stopCycleCount, int _vCycleCount, int _vSpeed, int _order, int _delayTick,int _funcId)

# 暂时没有实现
#0x3009=void Sprite_AddAcrossFlyString2(Object _processor, int _type, String _str, int _number, int _paletteColor, int _dir, int _hCycleCount, int _hSpeed, int _stopCycleCount, int _vCycleCount, int _vSpeed, int _order, int _delayTick, Object callbackData)

#预留0x300A-0x300F

#
0x3010=Object Sprite_GetCurrentAnimatePlayer(Object sprite)

#为精灵申请一个新的动画。
# 2010/12/11 Light: 采用新的Sprite接口，每个动画不用文件名作为key了，必须另外指定一个key
0x3011=void Sprite_RequestAnimate(Object sprite, String key, String fileName)

#设置精灵的显示或隐藏
0x3012=void Sprite_SetShow(Object sprite, boolean show)

#
0x3013=boolean Sprite_IsShowing(Object processor)

#为精灵添加一个Animate。
# 2010/12/12 Light: 这个方法原来是三国用来添加gamedata里正在载入中的动画的，新引擎中不用
#     这个方式了。一律统一成Sprite_RequestAnimate调用。
#0x3014=void Sprite_AddAnimate(Object sprite, String animateName)

#为精灵添加一个AnimatePlayer
0x3015=void Sprite_AddAnimatePlayer(Object sprite, AnimatePlayer ap)

#动画是否存在
# Light: 2010/12/11删除，用Sprite_GetCurrentAnimatePlayer() == NULL来判断。
#0x3016= boolean Sprite_AnimateIsExist(Object processor)

#设置精灵的某一个AnimatePlayer显示或隐藏
0x3017=void Sprite_SetAnimateShow(Object sprite, String animateName, boolean show)

#
0x3018=boolean AP_PlayEnd(Object processor, int apKey)

#查看精灵是否动画载入完毕
0x3019=boolean Sprite_AnimateReady(Object processor, String[] names)

#查看精灵是否拥有某个动画
0x301A=boolean Sprite_HasAnimate(Object sprite, String name)

#预留0x301B-0x301F

#
0x3020=int[] Sprite_GetAnimateBox(Object sprite)

#取得精灵的名字
0x3021=String Sprite_GetName(Object sprite)

#设置精灵的名字
0x3022=void Sprite_SetName(Object sprite, String _name)

#
0x3023=int Sprite_GetLevel(Object sprite)

#
0x3024=void Sprite_SetLevel(Object sprite, int _level)

#
0x3025=int Sprite_GetHP(Object sprite)

#
0x3026=int Sprite_GetHPMax(Object sprite)

#
0x3027=int Sprite_GetMP(Object sprite)

#
0x3028=int Sprite_GetMPMax(Object sprite)

#
0x3029=int[] Sprite_GetPos(Object sprite)

#预留0x302A-0x302F

#
0x3030=void Sprite_SetPos(Object sprite, int x, int y)

#
0x3031=void Sprite_SetHP(Object sprite, int hp)

#
0x3032=void Sprite_SetMP(Object sprite, int mp)

#
0x3033=void Sprite_SetHPMax(Object sprite, int hpMax)

#
0x3034=void Sprite_SetMPMax(Object sprite, int mpMax)

#
0x3035=int Sprite_GetX(Object sprite)

#
0x3036=int Sprite_GetY(Object sprite)

#
0x3037=int Sprite_GetMapID(Object sprite)

#
0x3038=int Sprite_GetMapInstanceID(Object sprite)

#
0x3039=int Sprite_PlayAttachAnimate(Object sprite, Object _animatePlayer, int _anchor, int _order)

#预留0x303A-0x303F

#
0x3040=Object Sprite_GetAttachAnimatePlayer(Object processor, int key)

#
0x3041=void Sprite_StopAttachAnimate(Object sprite, int _animatePlayerKey)

#移除精灵身上的某动画，通过动画名
0x3042= void Sprite_RemoveAttachAnimate(Object proc,String animateName)

#
0x3043=void Sprite_SetCanAttack(Object processor, boolean _canAttact)

#
0x3044=int Sprite_CanAttack(Object processor)

#
0x3045=void Sprite_SetCanSelect(Object processor, boolean _canSelect)

#
0x3046=int Sprite_CanSelect(Object processor)

#
0x3047=void Sprite_SetWaypointAnimate(Object processor, int _moveAnimate, int _stopAnimate, int _chaseMoveAnimate, int _chaseStopAnimate, int _pendingStopAnimate, int _chasePendingStopAnimate)

#
0x3048=void Sprite_SetHeadStringConfig(Object processor, int type, int space, int drawMode, int offsetX, int offsetY, int order)

#
0x3049=void Sprite_AddHeadString(Object processor, String _str, int _color, Object _image, int[] _imageIndex)

#预留0x304A-0x304F
0x304A=void Sprite_RemoveAllAttachAnimates()

# 移除精灵上所有附加动画。
0x304A=void Sprite_RemoveAllAttachAnimates(Object processor)

#
0x3050=void Sprite_ClearHeadString(Object processor)

#
0x3051=void Sprite_SetHeadStringShow(Object processor, boolean _show)

#
0x3052=void Sprite_SetCollision(Object processor, boolean _collision)

#取得精灵的类型
0x3053=int Sprite_GetType(Object processor)

#取得精灵的ID
0x3054=int Sprite_GetID(Object processor)

#取得精灵的instanceId
0x3055=int Sprite_GetInstanceID(Object processor)

#
0x3056=int Sprite_GetDir(Object processor)

#
0x3057=void Sprite_SetDir(Object processor, int _dir)

# 取得精灵上某个指定关键字的动画。
0x3058=Object Sprite_GetAnimatePlayer(Object processor, String _animateName)

#向精灵发送command
0x3059=void Sprite_SendCommond(Object processor, int _command, Object _data)

#预留0x305A-0x305F

#
0x3060=int Sprite_StartChasePosition(Object processor, int _distanceAllow, int _targetX, int _targetY, int _speed, int[] _callbackPara, boolean _always)

#
0x3061=int Sprite_StartChaseSprite(Object processor, int _distanceAllow, int _speed, Object _targetSprite, int[] _callbackPara, boolean _always)

#
0x3062=void Sprite_ClearChase(Object processor)

#
0x3063=void Sprite_AdjustAnimateDir(Object processor, int _targetInstanceId, boolean _setAnimate)

#获得精灵附加名称
0x3064=String[] Sprite_GetExtraName(Object processor)

#
0x3065=int Sprite_GetSpeed(Object _processor)

#
0x3066=void Sprite_SetSpeed(Object _processor, int _speed)

#
0x3067=int Sprite_GetAddonSpeed(Object _processor)

#
0x3068=void Sprite_SetAddonSpeed(Object _processor, int _speedAddon)

#
0x3069=void Sprite_SetAttacking(Object processor, boolean _attacking)

#预留0x306A-0x306F

#
0x3070=int Sprite_GetAnimateDir(Object processor)

#
0x3071=void Sprite_SetAnimateDir(Object processor, int _animateDir)

#
0x3072=int Sprite_GetMove(Object _processor)

#0x00CE=void SetMoving
0x3073=void Sprite_SetMoveing(Object processor, boolean moving)

#
0x3074=void Sprite_SetFollowing(Object processor, boolean isFollowing)

#
0x3075=int Sprite_GetFollowing(Object processor)

#
0x3076=Object Sprite_GetFollowOwner(Object processor)

#跟随  (-1 == gameRole) todo 0x50C8
#0x3077=boolean Sprite_AddFollower(int owner, int follower)

#移除跟随 (-1 == gameRole) todo 0x50C9
#0x3078 =void Sprite_RemoveFollower(int owner, int follower)

#
0x3079=void Sprite_SetLeavingPos(Object processor)

#预留0x307A-0x307F

#
0x3080=void Sprite_SetForceWayPoint(Object processor, boolean _hasReturnPoint, int _forceSpeed, int _returnX, int _returnY, int[] _wayPointList)

#
0x3081=void Sprite_ClearForceWayPoint(Object processor)

# Light: 废弃
0x3082=void Sprite_SetAnimateNotIcon(Object processor, String animateName)

#
0x3083=void Sprite_SetAnimateLayer(Object processor, String _animateName, int _layer)

#
0x3084=void Sprite_RegroupAnimate(Object processor)

#
0x3085=int Sprite_IsOutView(Object processor)

#
0x3086=void Sprite_SetHold(Object processor, boolean hold)

#todo 0x506E
#0x3087=int Sprite_IsTeamState(Object processor)

#todo 0x506F
#0x3088=void Sprite_SetTeamState(Object processor, boolean isTeamState)

0x3089=Object Sprite_GetAnimateList(Object sprite)

#预留0x308A-0x308F

#设置mapId
0x3090=void Sprite_SetMapID(Object sprite, int mapId)

0x3091=void Sprite_SetMapInstanceID(Object processor, int mapInstanceId)

#穿装备
0x3092=void Sprite_Equip(Object processor, String epName, String partKey)

#脱装备
0x3093=void Sprite_Unequip(Object processor, String partKey)

#是否穿装备
0x3094=boolean Sprite_HasEquip(Object processor, String partKey)

#为精灵添加一个素体动画
# Light: 2010/12/11 不计划再支持这个函数，素体动画和普通动画不做区别
#0x3095=void Sprite_AddHKAnimatePlayer(Object processor, String animateName, String hkName)

#获取角色带素体的动画
# Light: 2010/12/11 现在用Sprite_GetCurrentAnimatePlayer代替
#0x3096 =Object Sprite_GetHKAnimatePlayer(Object processor)

#0x00D0=void SetAnimate
0x3097=void Sprite_SetAnimate(Object processor, AnimatePlayer animatePlayer, int _index, int _playType, int _callBackIndex)

#
0x3098=void Sprite_SetAnimate2(Object processor, AnimatePlayer animatePlayer, int _index, int _playType, int _callBackIndex, Object callbackData, int tick)
0x3099=void Sprite_DrawHeadIcon(Object g, Object proc, int x, int y, boolean mirror)

# 绘制NPC头像。
0x3099=void Sprite_DrawHeadIcon(Object g, Object proc, int x, int y, boolean mirror)

#
0x309A= String Sprite_GetAnimatePlayerName(Object proc);

#
0x309B=void Sprite_SetType(Object _processor,byte type)

#================================================================================================
#@[0x3200 ~ 0x32FF]
#@引擎游戏接口---Quest SYSCALL FUNCTION ID:
#================================================================================================
#
0x3200=int Quest_AddETF(int _questId, int _type, int[] _startNpcId, int[] _endNpcId, byte[] _etf)

#
0x3201=void Quest_Add(int _questId, int _type, int[] _startNpcId, int[] _endNpcId)

#
0x3202=void Quest_Remove(int _questId)

#
0x3203=int Quest_UpdateETF(int _questId, byte[] _etf)

#
0x3204=void Quest_SetVar(int _questId, int _index, int _var)

#
0x3205=String Quest_TranslateText(int _questId, String _text)

#
0x3206=void Quest_SetState(int _questId, int _state)

#
0x3207=int Quest_GetState(int _questId)

#
0x3208=void Quest_ClearScene()

#0x00BA=Object GetQuest(int questId)
0x3209=Object Quest_Get(int questID)

#预留0x320A-0x320F

# #获得任务目标是否完成 0x012D=boolean QuestTargetDone
0x3210=boolean Quest_TargetDone(int questId, int targetIndex)

#================================================================================================
#@[0x3300 ~ 0x33FF]
#@引擎游戏接口---VMManager SYSCALL FUNCTION ID:
#================================================================================================


#
0x3301=int OpenUIWithParam(String vmId, Object[] param)

#
0x3302=void SetUICatchInput(boolean value)

#
0x3303=void SetUITransparent(boolean value)

#关闭脚本
0x3304=void CloseUI()

#关闭所有脚本
0x3305=void CloseAllUI(int type)

#
0x3306=String GetVMId(Object vmGame)

#
0x3307=void SetSingleton(boolean value)

#
0x3308=boolean GetSingleton(Object vmGame)

#
0x3309=Object GetVMGameByVMKey(int vmKey)

#预留0x330A-0x330F

# 把当前UI设置为顶层UI
0x330A=void SetUIToTop(String vmName)

# 设置种子VM，这个VM再reset的时候也不会被关闭
0x330B=void SetSeedVM(String vmName)

#获得一个vmgame         	
0x3310=Object GetVMGameByVMId(String vmName)

#
0x3311=boolean isTopUI()

#
0x3312=Object GetTopUIVM()

#
0x3313=int GetCommonKey()

#
0x3314=void LoadGameVm(String vmId)

#
0x3315=void RemoveGameVm(String vmId)

#
0x3316=Object[] GetVMParam(String vmId)

#
0x3317=Object GetCurrentVM()

#
0x3318=boolean IsBreak(VMGame vmGame)

#
0x3319=int PauseUICycle()

#
0x331A=void ResumeUICycle(int returnValue)

#预留0x331B-0x331F

#  #回调脚本内的一个方法            	
0x3320=Object VMCallback(String funcName, int callBackId, Object param)

# #关闭一个指定的脚本
0x3321=void CloseVM(String vmId)

# #关闭一个指定的脚本
0x3322=void CloseVMByVMKey(int vmKey)

# #获得VMGAME
0x3323=Hashtable GetVMGames()

#0x0132=void gameNotify
0x3324=void CallGameNotify(String vmId, int msgId, Object param)

#0x0133=int execByName
0x3325=int CallVMFunction(String vmName, String funcName, int[] paramAddrs)

#
0x3326=void AddEvent(int type, int param)

#
0x3327=int GetEventParam()

#
0x3328=void SetEventParam()

#
0x3329=int GetEventType()

##预留0x332A-0x332F

#
0x3330=void RegEvent(int type)

#
0x3331=void UnregEvent(int type)

#
0x3332=void UnregEvents()

#
0x3333=byte GetVMType(Object vmGame)

#================================================================================================
#@[0x3400 ~ 0x34FF]
#@引擎游戏接口---Resources SYSCALL FUNCTION ID:
#================================================================================================
#
0x3400=byte[] LoadResourceFile(String name)

#
0x3401=byte[] LoadFile(String name)

#
0x3402=boolean SaveFile(String name, byte[] data)

#
0x3403=void DeleteFile(String name)

#
0x3404=int ResAsynLoad(int loadType, String resName)

#
0x3405=int ResAsynCheck(int key)

#
0x3406=Object ResAsynGet(int key)

#
0x3407=String[] GetUpdateList()

#
0x3408=void SetUpdating(boolean updating)

#
0x3409=void UpdateFile(String name)


##预留0x340A-0x340F

#
0x3410=int GetUpdateMode()

# 请求和服务器同步版本。
0x3411=void SyncResource(boolean tryCompress)

#
0x3412=void ClearClientFileDb()

#
0x3413=void ClearWholeData()

#
0x3414=byte[] FindResource(String name)

#0x00E1=void ResRequestPkg
0x3415=void RequestResource(String name)

#
0x3416=void ResInitDeamonAnimatePlayer(Object animatePlayer, int deamonIndex)

#
0x3417=void ResSetDeamonAnimatePlayerArray(AnimatePlayer[] animatePlayers)

#
0x3418=Object ResGetDeamonAnimatePlayerCopy(int deamonIndex)

#
0x3419=void ResIninSpecialAnimatePlayer(int count)

# 处理服务器返回的同步版本结果包。
# 如果同步结束，返回-1；否则返回已完成的百分比（0-100）。
0x341A=int RecvSyncResource(UWAPSegment segment)

##预留0x341A-0x341F

#
0x3420=void ResSetSpecialAnimatePlayer(int index, Object animatePlayer)

#
0x3421=Object ResGetSpecialAnimatePlayer(int specialIndex, int index, int playerType, int callbackIndex, Object callbackObject)

#0x00DC=void ResSetInitializtion
0x3422=void ResSetInitializtion(int initializing)


#================================================================================================
#@[0x3500 ~ 0x35FF]
#@引擎游戏接口--- 工具 SYSCALL FUNCTION ID:
#================================================================================================
#
0x3500=String[] SplitString(String msg, int width)

#
0x3501=int Distance(int x1, int y1, int x2, int y2)

#
0x3502=int DrawMixedString(Object g, String str, int x, int y, int color, boolean is3D, int anchor)

#
0x3503=int DrawMixedString3D(Object g, String str, int x, int y, int color, int bkcolor, int anchor)

#
0x3504=int MixedStringWidth(String str)

#0x00E7=void ResDrawFrameBox
0x3505=void DrawFrameBox(Object g, int x, int y, int width, int height, int[] colors, boolean fill)

#0x00E8=void ResDrawBoxCorner
0x3506=void DrawBoxCorner(Object g, int x, int y, int width, int height, ImageSet image, int index, int mask)

#0x00E9=void ResDrawSpellRow
0x3507=void DrawSpellRow(Object g, int x, int y, int width, ImageSet image, int index, int trans)

#0x00EA=void ResDrawSpellCol
0x3508=void DrawSpellCol(Object g, int x, int y, int height, ImageSet image, int index, int trans)

#0x00EB=void ResDrawSpellArea
0x3509=void DrawSpellArea(Object g, int x, int y, int width, int height, ImageSet image, int index, int trans)

##预留0x350A-0x350F

#
0x3510=String[] GetStringArray(String value)

#
0x3511=String[] GetStringArray2(String str, String delimiter)

#
0x3512=void DrawBack(Graphics g,int x,int y,int width,int height)

#
0x3513=Vector FormatString(String msg, int w)

#
0x3514=void DrawImageNumber(Object g, ImageSet numberImg, int startIndex, String str, int x, int y, int space, int anchor)

# 获取字符串数组的最大宽度
0x3515=int GetStringsMaxWidth(String[] strings)

# 获取混合字符串数组的最大宽度
0x3516=int GetMixedStringsMaxWidth(String[] strings)

#sin值, 返回值扩大了 10000 
0x3517=int Sin(int angle)

#
0x3518=int Cos(int angle)
#added by zxf 2010-12-21
0x3519 = void sleep(int time)

# 设置系统图片文字。
0x3519=void SetSystemNumberImage(ImageSet img)

0x309B=void Sprite_SetType(Object _processor,byte type)

